# -*- coding: utf-8 -*-
"""CÃ³digo segmentaciÃ³n de imÃ¡genes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ugqRPUKsz6KYkwJlUuydROgyz6TtkmPZ
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **CÃ“DIGO FINAL**"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
from google.colab import files  # quita esta lÃ­nea si no estÃ¡s en Colab

# ============================
# 1ï¸âƒ£ Subir imagen del cariotipo
# ============================
print("ğŸ“¤ Por favor, sube la imagen del cariotipo...")
uploaded = files.upload()

# Obtener el nombre del archivo subido
for fn in uploaded.keys():
    imagen_path = fn
    print(f"âœ… Imagen cargada correctamente: {imagen_path}")

# ============================
# 2ï¸âƒ£ Cargar y preprocesar imagen
# ============================
img = cv2.imread(imagen_path)
if img is None:
    print("âŒ Error al cargar la imagen. Verifica el formato.")
    exit()

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blur = cv2.GaussianBlur(gray, (5,5), 0)

# UmbralizaciÃ³n adaptativa
_, thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

# Operaciones morfolÃ³gicas para limpiar ruido
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
clean = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=1)
clean = cv2.morphologyEx(clean, cv2.MORPH_CLOSE, kernel, iterations=1)

# ============================
# 3ï¸âƒ£ DetecciÃ³n de contornos (cromosomas o pares)
# ============================
contours, _ = cv2.findContours(clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

boxes = []
for c in contours:
    x, y, w, h = cv2.boundingRect(c)
    if w > 10 and h > 20:  # filtro para eliminar ruido pequeÃ±o
        boxes.append((x, y, w, h))

# Ordenar por posiciÃ³n visual
boxes = sorted(boxes, key=lambda b: (b[1]//100, b[0]))

# ============================
# 4ï¸âƒ£ Crear carpeta de salida Ãºnica por ejecuciÃ³n
# ============================
base_name = "cariotipo_recortados"
num = 1
while os.path.exists(f"{base_name}_{num}"):
    num += 1
output_folder = f"{base_name}_{num}"
os.makedirs(output_folder, exist_ok=True)
print(f"ğŸ“ Carpeta creada: '{output_folder}'")

# ============================
# 5ï¸âƒ£ Recortar y dividir si hay dos pegados
# ============================
cromosomas_individuales = []
for (x, y, w, h) in boxes:
    crom = img[y:y+h, x:x+w]
    # Si el recorte es demasiado ancho, probablemente tiene dos cromosomas
    if w/h > 0.7:
        sub_gray = cv2.cvtColor(crom, cv2.COLOR_BGR2GRAY)
        profile = np.sum(255 - sub_gray, axis=0)
        min_idx = np.argmin(profile)
        if 10 < min_idx < w - 10:
            crom1 = crom[:, :min_idx]
            crom2 = crom[:, min_idx:]
            cromosomas_individuales.append(crom1)
            cromosomas_individuales.append(crom2)
        else:
            cromosomas_individuales.append(crom)
    else:
        cromosomas_individuales.append(crom)

# Si hay mÃ¡s de 46, recortar los mÃ¡s grandes
if len(cromosomas_individuales) > 46:
    cromosomas_individuales = sorted(
        cromosomas_individuales,
        key=lambda im: im.shape[0]*im.shape[1],
        reverse=True
    )[:46]

print(f"ğŸ§¬ Se generaron {len(cromosomas_individuales)} cromosomas individuales.")

# ============================
# 6ï¸âƒ£ Guardar recortes en la carpeta
# ============================
for i, crom in enumerate(cromosomas_individuales, start=1):
    nombre = f"cromosoma_{i:02d}.png"
    ruta = os.path.join(output_folder, nombre)
    cv2.imwrite(ruta, crom)

print(f"âœ… Se guardaron {len(cromosomas_individuales)} cromosomas individuales en '{output_folder}'")

# ============================
# 7ï¸âƒ£ Mostrar miniaturas
# ============================
plt.figure(figsize=(12, 10))
cols = 8
rows = (len(cromosomas_individuales) + cols - 1) // cols
for i, crom in enumerate(cromosomas_individuales, start=1):
    crom_rgb = cv2.cvtColor(crom, cv2.COLOR_BGR2RGB)
    plt.subplot(rows, cols, i)
    plt.imshow(crom_rgb)
    plt.axis("off")
    plt.title(f"{i}")
plt.suptitle(f"Cromosomas recortados - {output_folder}", fontsize=14)
plt.tight_layout()
plt.show()

# ============================
# 8ï¸âƒ£ AnÃ¡lisis de Ã¡rea de cada cromosoma
# ============================
areas = []
for i, crom in enumerate(cromosomas_individuales):
    area = crom.shape[0] * crom.shape[1]  # altura Ã— ancho
    areas.append((i, area))

# Ordenar por Ã¡rea (de menor a mayor)
areas_sorted = sorted(areas, key=lambda x: x[1])
print("\nğŸ“Š Ãreas de los cromosomas (Ã­ndice, Ã¡rea en pÃ­xeles):")
for idx, area in areas_sorted[:10]:  # muestra los 10 mÃ¡s pequeÃ±os
    print(f"  Cromosoma {idx+1}: {area} px")

# Los 4 cromosomas mÃ¡s pequeÃ±os como candidatos (por si hay ruido o error)
num_candidatos = min(6, len(cromosomas_individuales))
candidatos_21 = [idx for idx, area in areas_sorted[:num_candidatos]]

print(f"\nğŸ” Candidatos a cromosoma 21 (Ã­ndices 0-based): {[i+1 for i in candidatos_21]}")

# ============================
# 9ï¸âƒ£ DiagnÃ³stico preliminar: Â¿posible trisomÃ­a 21?
# ============================
# Asumimos que el cromosoma 21 aparece 2 veces en normal, 3 en trisomÃ­a.
# Vamos a tomar los 3 mÃ¡s pequeÃ±os y ver si sus Ã¡reas son muy similares.
if len(cromosomas_individuales) >= 3:
    top3 = areas_sorted[:3]
    idxs_top3 = [t[0] for t in top3]
    areas_top3 = [t[1] for t in top3]

    # Calcular coeficiente de variaciÃ³n (CV) para ver si son similares
    mean_area = np.mean(areas_top3)
    std_area = np.std(areas_top3)
    cv = (std_area / mean_area) * 100 if mean_area > 0 else float('inf')

    print(f"\nğŸ“ Ãreas de los 3 cromosomas mÃ¡s pequeÃ±os: {areas_top3}")
    print(f"ğŸ“ˆ Coeficiente de variaciÃ³n: {cv:.2f}%")

    # Si CV < 30% â†’ Ã¡reas muy parecidas â†’ posible trisomÃ­a
    if cv < 30 and len(cromosomas_individuales) >= 45:  # evitar falsos con pocos cromosomas
        print("â—âš ï¸  ALERTA: Los 3 cromosomas mÃ¡s pequeÃ±os tienen Ã¡reas muy similares.")
        print("   â†’ Posible trisomÃ­a 21 (SÃ­ndrome de Down).")
        diagnostico = "Posible trisomÃ­a 21"
    else:
        print("âœ… Normal: No se detectan 3 cromosomas 21 similares.")
        diagnostico = "Normal (2 cromosomas 21 esperados)"
else:
    print("âš ï¸ No hay suficientes cromosomas para evaluar trisomÃ­a 21.")
    diagnostico = "Insuficientes datos"

# ============================
# ğŸ”Ÿ Mostrar los candidatos a cromosoma 21
# ============================
candidatos_imgs = [cromosomas_individuales[i] for i in candidatos_21]

plt.figure(figsize=(10, 4))
for i, crom in enumerate(candidatos_imgs):
    plt.subplot(2, 3, i+1)
    crom_rgb = cv2.cvtColor(crom, cv2.COLOR_BGR2RGB)
    plt.imshow(crom_rgb)
    plt.axis("off")
    plt.title(f"Candidato {candidatos_21[i]+1}\n{areas[candidatos_21[i]][1]} px", fontsize=10)

plt.suptitle(f"ğŸ” Candidatos a cromosoma 21 ({diagnostico})", fontsize=14)
plt.tight_layout()
plt.show()

# ============================
# ğŸ“Œ Resumen final
# ============================
print("\n" + "="*50)
print("ğŸ“‹ RESUMEN DEL ANÃLISIS")
print(f"â€¢ Total de cromosomas detectados: {len(cromosomas_individuales)}")
print(f"â€¢ DiagnÃ³stico preliminar: {diagnostico}")
print("="*50)

